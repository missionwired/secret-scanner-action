name: "Detect Secrets Scanner"
description: "Scan files for hardcoded secrets, convert results to SARIF, and optionally upload to GitHub Code Scanning."
inputs:
  scan-path:
    description: "The directory to scan for secrets (e.g., ./src/dist). Defaults to ./build"
    required: false
    default: "./build"

  upload-sarif:
    description: "Whether to upload SARIF results to GitHub Code Scanning (true/false)."
    required: false
    default: "true"

  exclude-files-regex: 
    description: "A single regex pattern for files to exclude from scanning (e.g., .*/test/.*|.*\\.min\\.js)."
    required: false
    default: ""

  fail-on-detection:
    description: "Whether to fail the workflow if secrets are detected (true) or just warn (false)."
    required: false
    default: "true"

runs:
  using: "composite"
  steps:
    - name: Install detect-secrets
      shell: bash
      # jq is assumed to be pre-installed on standard GitHub runners (ubuntu-latest)
      run: |
        python3 -m pip install --upgrade pip
        pip install detect-secrets

    - name: Run detect-secrets scan and generate SARIF
      id: secret-scan
      shell: bash
      env:
        # Pass the regex pattern to the shell environment to avoid quoting issues with run: |
        EXCLUDE_REGEX: ${{ inputs.exclude-files-regex }} 
      run: |
        # Base command: always include --all-files so we scan everything under scan-path
        SCAN_CMD=(
          detect-secrets
          scan
          --all-files
          "${{ inputs.scan-path }}"
        )

        # Disable noisy plugins by default
        SCAN_CMD+=(--disable-plugin ArtifactoryDetector)
        SCAN_CMD+=(--disable-plugin Base64HighEntropyString)
        SCAN_CMD+=(--disable-plugin HexHighEntropyString)
        SCAN_CMD+=(--disable-plugin KeywordDetector)

        # Append --exclude-files if that input is provided
        if [ -n "${EXCLUDE_REGEX}" ]; then
          SCAN_CMD+=(--exclude-files "${EXCLUDE_REGEX}")
          echo "Excluding files from scan: ${EXCLUDE_REGEX}"
        fi

        # Execute the scan command and output to JSON
        "${SCAN_CMD[@]}" > detect-secrets-output.json

        # Use the action's internal path to find the JQ script
        jq -f "${{ github.action_path }}/detect-secrets-to-sarif.jq" detect-secrets-output.json > detect-secrets-results.sarif

        SECRET_COUNT=$(jq '.runs[].results | length' detect-secrets-results.sarif)
        echo "Secret findings: $SECRET_COUNT"
        echo "secret_count=$SECRET_COUNT" >> $GITHUB_OUTPUT

        # Provide clear output and handle build breaking logic
        if [ "$SECRET_COUNT" -gt 0 ]; then
          ERROR_MESSAGE="The secret scanner found $SECRET_COUNT hardcoded secrets. Review the Code Scanning results or detect-secrets-results.sarif for details."

          if [ "${{ inputs.fail-on-detection }}" = "true" ]; then
            echo "::error title=Hardcoded Secrets Found::${ERROR_MESSAGE}"
            exit 1
          else
            echo "::warning title=Hardcoded Secrets Found::${ERROR_MESSAGE}"
          fi
        else
          echo "::notice::Secret scanning completed successfully. No hardcoded secrets were detected."
        fi

    - name: Upload SARIF to GitHub Code Scanning
      # Only runs if 'upload-sarif' is true (for MW) and secrets were found
      if: ${{ inputs.upload-sarif == 'true' && steps.secret-scan.outputs.secret_count > 0 }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: detect-secrets-results.sarif
        category: detect-secrets
