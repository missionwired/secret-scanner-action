name: Detect Secrets Scanner
description: Scan files for hardcoded secrets, convert results to SARIF, and optionally upload to GitHub Code Scanning.
inputs:
  scan-path:
    description: Directory to scan for secrets (e.g., ./src) Defaults to repository root.
    required: false
    default: .
  upload-sarif:
    description: Upload SARIF results to GitHub Code Scanning (true/false).
    required: false
    default: 'true'
  exclude-files-regex:
    description: Regex pattern for files to exclude (single pattern).
    required: false
    default: ''
  scan-all-files:
    description: Scan all files including untracked/build artifacts (true/false). Default scans all files.
    required: false
    default: 'false'
  fail-on-detection:
    description: Fail workflow if secrets detected (true/false).
    required: false
    default: 'true'
  debug-mode:
    description: Enable verbose diagnostic logging (true/false).
    required: false
    default: 'false'
  always-upload:
    description: Upload SARIF even if zero findings (true/false).
    required: false
    default: 'false'
  wait-for-processing:
    description: Wait for SARIF ingestion (true/false).
    required: false
    default: 'true'
  checkout-path:
    description: Path repository was checked out to (for path relativization in SARIF).
    required: false
    default: ${{ github.workspace }}
  detect-secrets-version:
    description: Pin detect-secrets version (e.g., 1.5.0). Blank = latest.
    required: false
    default: ''
  use-baseline:
    description: Use baseline file to track known secrets (recommended for production).
    required: false
    default: 'false'
  baseline-file:
    description: Path to detect-secrets baseline file (relative to repository root).
    required: false
    default: '.secrets.baseline'

runs:
  using: composite
  steps:
    - name: Debug Context
      if: ${{ inputs.debug-mode == 'true' }}
      shell: bash
      run: |
        echo "::group::Debug Context"
        echo "Event: $GITHUB_EVENT_NAME"
        echo "Ref: $GITHUB_REF"
        echo "SHA: $GITHUB_SHA"
        echo "Workspace: $GITHUB_WORKSPACE"
        echo "Scan Path: ${{ inputs.scan-path }}"
        echo "Exclude Regex: ${{ inputs.exclude-files-regex }}"
        echo "Always Upload: ${{ inputs.always-upload }}"
        echo "Wait For Processing: ${{ inputs.wait-for-processing }}"
        echo "Use Baseline: ${{ inputs.use-baseline }}"
        echo "Baseline File: ${{ inputs.baseline-file }}"
        echo "::endgroup::"

        echo "::group::Dependency Check"
        echo "✓ python3: $(python3 --version 2>&1 || echo 'NOT FOUND')"
        echo "✓ pip: $(pip --version 2>&1 || pip3 --version 2>&1 || echo 'NOT FOUND')"
        echo "✓ jq: $(jq --version 2>&1 || echo 'NOT FOUND')"
        echo "::endgroup::"

    - name: Install detect-secrets
      shell: bash
      run: |
        echo "[secret-scan] Install phase - youre on the right branch louuuuuuuuuu"
        set -euo pipefail
        echo "::group::Installing detect-secrets"
        python3 -m pip install --upgrade pip --quiet
        if [[ -n "${{ inputs.detect-secrets-version }}" ]]; then
          pip install "detect-secrets==${{ inputs.detect-secrets-version }}" --quiet
        else
          pip install detect-secrets --quiet 
        fi
        echo "::endgroup::"

    - name: Scan for secrets and generate SARIF report
      id: secret-scan
      shell: bash
      env:
        EXCLUDE_REGEX: ${{ inputs.exclude-files-regex }}
        DEBUG_MODE: ${{ inputs.debug-mode }}
        SCAN_PATH: ${{ inputs.scan-path }}
        USE_BASELINE: ${{ inputs.use-baseline }}
        BASELINE_FILE: ${{ inputs.baseline-file }}
      run: |
        echo "[secret-scan] Scan phase"
        set -euo pipefail

        # Basic input validation - check path exists
        if [[ ! -e "${SCAN_PATH}" ]]; then
          echo "::error::Scan path '${SCAN_PATH}' does not exist"
          exit 1
        fi

        # Handle baseline file and determine scan command
        BASELINE_EXISTS=false
        USE_HOOK_MODE=false

        if [[ "${USE_BASELINE}" == "true" ]]; then
          if [[ -f "${BASELINE_FILE}" ]]; then
            BASELINE_EXISTS=true
            echo "::notice::Using existing baseline file: ${BASELINE_FILE}"
          else
            echo "::error::Baseline mode enabled but baseline file '${BASELINE_FILE}' not found."
            echo "::error::Create baseline file first: 'detect-secrets scan --all-files > ${BASELINE_FILE}'"
            echo "::error::Then audit it: 'detect-secrets audit ${BASELINE_FILE}'"
            echo "::error::Finally commit the baseline file to your repository."
            exit 1
          fi
        else
          echo "::warning::Baseline mode disabled. Git history will be scanned and may produce repeated alerts."
          echo "::warning::For production use, enable 'use-baseline: true' to track known secrets."
        fi

          # Use scan mode - shows ALL secrets
          SCAN_CMD=(
            detect-secrets
            scan
            "${SCAN_PATH}"
          )
          echo "::debug::Using detect-secrets scan mode (shows all secrets - not using baseline file)"
        
        # TODO: If I pass in a scan path - do I need the --all-files flag?
        # # Add --all-files flag if explicitly requested (for build artifacts)
        if [[ "${{ inputs.scan-all-files }}" == "true" && USE_HOOK_MODE == "false" ]]; then
          SCAN_CMD+=(--all-files)
          echo "::debug::Scanning all files including untracked/build artifacts"
        else
          echo "::debug::Scanning git-tracked files only"
        fi

        # Disable noisy plugins
        SCAN_CMD+=(--disable-plugin ArtifactoryDetector)
        SCAN_CMD+=(--disable-plugin Base64HighEntropyString)
        SCAN_CMD+=(--disable-plugin HexHighEntropyString)
        SCAN_CMD+=(--disable-plugin KeywordDetector)

        if [[ -n "${EXCLUDE_REGEX}" ]]; then
          SCAN_CMD+=(--exclude-files "${EXCLUDE_REGEX}")
          echo "::debug::Excluding files matching: ${EXCLUDE_REGEX}"
        fi

        echo "::group::Scanning for secrets"
        if [[ "${DEBUG_MODE}" == "true" ]]; then
          echo "[secret-scan] Command: ${SCAN_CMD[*]}"
        fi

        "${SCAN_CMD[@]}" > detect-secrets-output.json

        # ============================================================================
        # BASELINE COMPARISON LOGIC (Hash-based)
        # ============================================================================
        # This section compares secrets found in the current scan against a baseline
        # file to determine if NEW secrets have been introduced.
        #
        # Why use hashes?
        # - Each secret has a unique 'hashed_secret' value (SHA-1 hash)
        # - Comparing hashes is more robust than just counting secrets
        # - Detects if old secrets are removed but new ones added (net zero count change)
        # - Allows us to identify WHICH secrets are new
        # ============================================================================

        # Count total secrets in current scan
        # This jq expression:
        # 1. Gets the .results object (or empty object if missing)
        # 2. For each file, gets the length of its secret array
        # 3. Sums all lengths together (defaults to 0 if no secrets)
        SECRET_COUNT=$(jq -r '(.results? // {}) | [ .[] | length ] | add // 0' detect-secrets-output.json 2>/dev/null || echo 0)

        # Validate that SECRET_COUNT is a valid number
        if [[ -z "${SECRET_COUNT}" || "${SECRET_COUNT}" == "null" || ! "${SECRET_COUNT}" =~ ^[0-9]+$ ]]; then
          echo "::warning::Secret count validation failed. Result was '${SECRET_COUNT}'. Defaulting count to 0 to avoid workflow disruption."
          SECRET_COUNT=0
        fi

        # Initialize variables for comparison logic
        NEW_SECRET_COUNT=0
        BASELINE_COUNT=0
        SHOULD_FAIL=false

        # If baseline mode is enabled, perform hash-based comparison
        if [[ "${USE_BASELINE}" == "true" && "${BASELINE_EXISTS}" == "true" ]]; then
          echo "::group::Baseline Comparison"

          # Extract all hashed_secret values from BASELINE file
          # This creates a sorted list of known secret hashes (one per line)
          # Example output:
          #   25910f981e85ca04baf359199dd0bd4a3ae738b6
          #   a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
          BASELINE_HASHES=$(jq -r '[.results[][] | .hashed_secret] | sort | unique | .[]' "${BASELINE_FILE}" 2>/dev/null || echo "")

          # Count how many known secrets are in the baseline
          if [[ -n "${BASELINE_HASHES}" ]]; then
            BASELINE_COUNT=$(echo "${BASELINE_HASHES}" | wc -l | tr -d ' ')
          fi

          echo "::debug::Baseline contains ${BASELINE_COUNT} known secret(s)"

          # Extract all hashed_secret values from CURRENT SCAN
          # Same format as baseline hashes
          CURRENT_HASHES=$(jq -r '[.results[][] | .hashed_secret] | sort | unique | .[]' detect-secrets-output.json 2>/dev/null || echo "")

          echo "::debug::Current scan found ${SECRET_COUNT} total secret(s)"

          # Compare hashes to find NEW secrets
          # comm -13: Compare two sorted files and show lines only in file 2
          #   -1 = suppress lines only in file 1 (baseline)
          #   -3 = suppress lines in both files (known secrets)
          #   Result = lines only in file 2 (NEW secrets not in baseline)
          if [[ -n "${CURRENT_HASHES}" ]]; then
            # Create temporary files for comm command (requires actual files)
            echo "${BASELINE_HASHES}" > baseline_hashes.txt
            echo "${CURRENT_HASHES}" > current_hashes.txt

            # Find hashes that exist in current scan but NOT in baseline
            NEW_HASHES=$(comm -13 baseline_hashes.txt current_hashes.txt)
            NEW_SECRET_COUNT=$(echo "${NEW_HASHES}" | grep -c . || echo 0)

            # Debug output: show which secrets are new
            if [[ "${DEBUG_MODE}" == "true" && ${NEW_SECRET_COUNT} -gt 0 ]]; then
              echo "::debug::New secret hashes detected:"
              echo "${NEW_HASHES}" | while read -r hash; do
                # Find the file and line number for each new secret
                jq -r --arg hash "$hash" '.results | to_entries[] | select(.value[] | .hashed_secret == $hash) | "\(.key):\(.value[] | select(.hashed_secret == $hash) | .line_number)"' detect-secrets-output.json
              done
            fi

            # Clean up temporary files
            rm -f baseline_hashes.txt current_hashes.txt
          fi

          echo "::endgroup::"

          # Determine if we should fail the build
          if [[ ${NEW_SECRET_COUNT} -gt 0 ]]; then
            # NEW secrets detected - this is a failure condition
            SHOULD_FAIL=true
            ERROR_MESSAGE="Found ${NEW_SECRET_COUNT} NEW secret(s) not in baseline (${BASELINE_COUNT} known secrets ignored). Check Security → Code scanning alerts."

            if [[ "${{ inputs.fail-on-detection }}" == "true" ]]; then
              echo "fail_after_upload=true" >> "${GITHUB_OUTPUT}"
              echo "::error title=New Secrets Detected::${ERROR_MESSAGE}"
            else
              echo "::warning title=New Secrets Detected::${ERROR_MESSAGE}"
            fi
          else
            # No new secrets - all secrets are in the baseline (known/approved)
            echo "::notice title=Baseline Check Passed::No new secrets detected. ${SECRET_COUNT} known secret(s) in baseline."
          fi

        else
          # Baseline mode is DISABLED - fail if ANY secrets are found
          # This is the "strict mode" where no secrets are allowed
          echo "::debug::Baseline mode disabled - checking for any secrets"

          if [[ "${SECRET_COUNT}" -gt 0 ]]; then
            SHOULD_FAIL=true

            if [[ "${{ inputs.upload-sarif }}" == "true" ]]; then
              DETAILS_MESSAGE="Check Security → Code scanning alerts (category: detect-secrets)."
            else
              DETAILS_MESSAGE="Review detect-secrets-results.sarif."
            fi

            ERROR_MESSAGE="Found ${SECRET_COUNT} potential hardcoded secret(s). ${DETAILS_MESSAGE}"

            if [[ "${{ inputs.fail-on-detection }}" == "true" ]]; then
              echo "fail_after_upload=true" >> "${GITHUB_OUTPUT}"
              echo "::error title=Secrets Detected::${ERROR_MESSAGE}"
            else
              echo "::warning title=Secrets Detected::${ERROR_MESSAGE}"
            fi
          else
            echo "::notice title=Secret Scan Complete::No hardcoded secrets detected."
          fi
        fi

        # Store outputs for later steps
        echo "secret_count=${SECRET_COUNT}" >> "${GITHUB_OUTPUT}"
        echo "new_secret_count=${NEW_SECRET_COUNT}" >> "${GITHUB_OUTPUT}"
        echo "baseline_count=${BASELINE_COUNT}" >> "${GITHUB_OUTPUT}"
        echo "[secret-scan] Findings: ${SECRET_COUNT} total, ${NEW_SECRET_COUNT} new, ${BASELINE_COUNT} in baseline"

        # ============================================================================
        # SARIF CONVERSION
        # ============================================================================
        # Convert detect-secrets JSON format to SARIF format for GitHub Code Scanning
        # This allows secrets to appear in the Code Scanning tab of the repository
        jq \
          --arg repoUri "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}" \
          --arg revision "${GITHUB_SHA}" \
          --arg branch "${GITHUB_REF_NAME}" \
          -f "${{ github.action_path }}/detect-secrets-to-sarif.jq" \
          detect-secrets-output.json > detect-secrets-results.sarif

        # Debug: Validate SARIF conversion
        if [[ "${DEBUG_MODE}" == "true" ]]; then
          SARIF_COUNT=$(jq -r '[ .runs[]? | ( .results? // [] ) | length ] | add // 0' detect-secrets-results.sarif 2>/dev/null || echo 0)
          echo "::group::SARIF Diagnostics"
          echo "Raw Secret Count: ${SECRET_COUNT}"
          echo "SARIF Secret Count: ${SARIF_COUNT}"
          if [[ "${SARIF_COUNT}" != "${SECRET_COUNT}" ]]; then
            echo "::warning::Mismatch between raw and SARIF counts (raw=${SECRET_COUNT}, sarif=${SARIF_COUNT})"
          fi
          head -n 25 detect-secrets-results.sarif || true
          echo "::endgroup::"
        fi

    - name: Upload SARIF to GitHub Code Scanning
      if: ${{ inputs.upload-sarif == 'true' && (inputs.always-upload == 'true' || steps.secret-scan.outputs.secret_count > 0) }}
      uses: github/codeql-action/upload-sarif@v4
      with:
        sarif_file: detect-secrets-results.sarif
        category: detect-secrets
        wait-for-processing: ${{ inputs.wait-for-processing }}
        checkout_path: ${{ inputs.checkout-path }}

    - name: SARIF Artifact (debug only)
      if: ${{ inputs.debug-mode == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: detect-secrets-sarif
        path: detect-secrets-results.sarif
        retention-days: 5

    - name: Fail if secrets were detected
      if: ${{ steps.secret-scan.outputs.fail_after_upload == 'true' }}
      shell: bash
      run: |
        echo "Failing build due to detected secrets."
        exit 1